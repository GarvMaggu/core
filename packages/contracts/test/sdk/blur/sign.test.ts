import { Contract } from "@ethersproject/contracts";
import { parseEther } from "@ethersproject/units";
import * as Common from "@reservoir0x/sdk/src/common";
import * as Blur from "@reservoir0x/sdk/src/blur";
import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/dist/src/signer-with-address";
import { expect } from "chai";
import { ethers } from "hardhat";
import { utils } from "ethers";
import { MerkleTree } from 'merkletreejs';

import { getChainId, getCurrentTimestamp, reset, setupNFTs } from "../../utils";

describe("Blur - SingleToken Erc721", () => {
  const chainId = getChainId();

  let deployer: SignerWithAddress;
  let alice: SignerWithAddress;
  let bob: SignerWithAddress;
  let carol: SignerWithAddress;
  let ted: SignerWithAddress;

  let erc721: Contract;

  beforeEach(async () => {
    [deployer, alice, bob, carol, ted] = await ethers.getSigners();
    ({ erc721 } = await setupNFTs(deployer));
  });

  afterEach(reset);

  it("sign", async () => {
    const exchange = new Blur.Exchange(chainId);
    const builder = new Blur.Builders.SingleToken(chainId);

    const inputData = exchange.contract.interface.decodeFunctionData("execute", `0x9a1fc3a70000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000036000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000001b602a8015af4f4f897adde7cc5ec0701f422789b4828ac0f1899ee245764c3884739c1b50aaddb4b4f2a1c602976997d99e9968f39dff0ec282eea5b753534a2c000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f23eb100000000000000000000000029e44b41e191531b07d6b5cb9e03c3bece1373aa000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000006411739da1c40b106f8511de5d1fac0000000000000000000000003fe1a4c1481c8351e91b64d5c398b159de07cbc50000000000000000000000000000000000000000000000000000000000000c820000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003311fc80a57000000000000000000000000000000000000000000000000000000000000635e83ff000000000000000000000000000000000000000000000000000000006367be7e00000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000002b909f741233a66b1750c4e867ae7675000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000064000000000000000000000000aae014af95d811ad7dbff60209e74551a338f64c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f23eb10000000000000000000000002128f6d85dfdd6cf1b92eebf38eab41716e5becd000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006411739da1c40b106f8511de5d1fac0000000000000000000000003fe1a4c1481c8351e91b64d5c398b159de07cbc50000000000000000000000000000000000000000000000000000000000000c820000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003311fc80a5700000000000000000000000000000000000000000000000000000000000063611e6a0000000000000000000000000000000000000000000000000000000063613a8a00000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000009a0ed79db7e1083b50890a647607f64900000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`);
    // console.log('inputData.buy', inputData.buy)
    // console.log('inputData.sell', inputData.sell)
    const sellOrder1 = inputData.sell[0]
    // const curTimestamp = (await getCurrentTimestamp(ethers.provider));
    // console.log("curTimestamp", curTimestamp)

    function getOrder(sellOrder: any) {
      console.log('sellOrder', sellOrder)
      return {
        side: sellOrder.side === 1 ? "sell" : "buy",
        trader: sellOrder.trader,
        collection: sellOrder.collection,
        tokenId: sellOrder.tokenId.toString(),
        amount: sellOrder.amount.toString(),
        paymentToken: sellOrder.paymentToken,
        price: sellOrder.price.toString(),
        listingTime: sellOrder.listingTime.toString(),
        matchingPolicy: sellOrder.matchingPolicy,
        nonce: 0,
        expirationTime: sellOrder.expirationTime.toString(),
        fees: sellOrder.fees.map((_:any) => {
          return {
            rate: _.rate,
            recipient: _.recipient
          }
        }),
        salt: sellOrder.salt.toString(),
        extraParams: sellOrder.extraParams
      }
    }

    // console.log('sellOrder', getOrder(sellOrder1))
    // console.log('buyOrder', getOrder(inputData.buy[0]))
    const buyOrder = builder.build({
      side: "sell",
      trader: sellOrder1.trader,
      collection: sellOrder1.collection,
      tokenId: sellOrder1.tokenId.toString(),
      amount: sellOrder1.amount.toString(),
      paymentToken: sellOrder1.paymentToken,
      price: sellOrder1.price.toString(),
      listingTime: sellOrder1.listingTime.toString(),
      matchingPolicy: sellOrder1.matchingPolicy,
      nonce: 0,
      expirationTime: sellOrder1.expirationTime.toString(),
      fees: sellOrder1.fees.map((_:any) => {
        return {
          rate: _.rate,
          recipient: _.recipient
        }
      }),
      salt: sellOrder1.salt.toString(),
      extraParams: sellOrder1.extraParams
    });

    

    const tx = await ethers.provider.getTransactionReceipt('0xc02aa94cd1b594d93afd2e5ea7890402f3b38329abdb5f188bf449ebb4dbd12a');
    const orderHash = buyOrder.hash()
    const eventData = exchange.contract.interface.decodeEventLog('OrdersMatched', tx.logs[3].data);
    // console.log("OrdersMatched",eventData.sellHash)



    expect(orderHash).to.be.eq(eventData.sellHash)

  });

  it("bulkSign", async() => {
    const rawData = `0x9a1fc3a70000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000001bacee62d7acadd0ae2b3a3a5a674f97671659ce51c9c292ac4a4c2193b3a0891042c94a13168ff144eb30131161d8b0aabb588296d5db1713ce58fd480d3bf09700000000000000000000000000000000000000000000000000000000000002c000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000f26fdf000000000000000000000000f65d928d8c143e49096cf666095a2be54bd431eb000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000006411739da1c40b106f8511de5d1fac00000000000000000000000005da517b1bf9999b7762eaefa8372341a1a475590000000000000000000000000000000000000000000000000000000000001668000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000917070797e18000000000000000000000000000000000000000000000000000000000006362a59800000000000000000000000000000000000000000000000000000000638a329800000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000053cae46abac64a5d1dc3a8ad0746b5c00000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000001d89573ca21c1878c2b55da13ef170bbcd599defb26a6e277239b686e38bb1e1900000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f26fdf00000000000000000000000000fb2499403afeccd48f0fb29da41cde8c113d4b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006411739da1c40b106f8511de5d1fac00000000000000000000000005da517b1bf9999b7762eaefa8372341a1a475590000000000000000000000000000000000000000000000000000000000001668000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000917070797e180000000000000000000000000000000000000000000000000000000000063636fa90000000000000000000000000000000000000000000000000000000063638bc900000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000002d01851a2889aa9cb3ccd62f4322510e00000000000000000000000000000000000000000000000000000000000001c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`
    const exchange = new Blur.Exchange(chainId);
    const builder = new Blur.Builders.SingleToken(chainId);
    const inputData = exchange.contract.interface.decodeFunctionData("execute", rawData);
   

    function getOrder(sellOrder: any) {
      console.log('sellOrder', sellOrder)
      return {
        side: sellOrder.side === 1 ? "sell" : "buy",
        trader: sellOrder.trader,
        collection: sellOrder.collection,
        tokenId: sellOrder.tokenId.toString(),
        amount: sellOrder.amount.toString(),
        paymentToken: sellOrder.paymentToken,
        price: sellOrder.price.toString(),
        listingTime: sellOrder.listingTime.toString(),
        matchingPolicy: sellOrder.matchingPolicy,
        nonce: 0,
        expirationTime: sellOrder.expirationTime.toString(),
        fees: sellOrder.fees.map((_:any) => {
          return {
            rate: _.rate,
            recipient: _.recipient
          }
        }),
        salt: sellOrder.salt.toString(),
        extraParams: sellOrder.extraParams,
        r: sellOrder.r,
        v: sellOrder.v,
        s: sellOrder.s,
        extraSignature: sellOrder.extraSignature,
        signatureVersion: sellOrder.signatureVersion,
      }
    }

    // console.log('rawOrder', inputData.sell[0])
    const sellOrderRaw = getOrder(inputData.sell[0]);
    const sellOrder = builder.build(sellOrderRaw as any);

    const sellOrderHash = sellOrder.hash();
    console.log('orderHash', sellOrderHash)

    const abiDecorder = new utils.AbiCoder();
    const sellInput = inputData.sell;
    const merklePath = abiDecorder.decode(
      ['bytes32[]'],
      sellInput.extraSignature
    )
    console.log('sellInput', sellInput.extraSignature, merklePath)

    function computeRoot(leaf: string, proof: string[]) {
      let computedHash = leaf;
      for (let i = 0; i < proof.length; i++) {
          const proofElement = proof[i];
          console.log({
            proofElement,
            computedHash
          })
          if (computedHash <= proofElement) {
              computedHash = utils.solidityKeccak256(['byte32', 'byte32'],[computedHash, proofElement]);
          } else {
              computedHash = utils.solidityKeccak256(['byte32', 'byte32'], [proofElement, computedHash]);
          }
      }
      return computedHash;
    }

    // const tree = new MerkleTree([]);
    // tree.addLeaf(MerkleTree.bufferify(sellOrderHash));
    const root = computeRoot(sellOrderHash, merklePath[0]);
    console.log("root", root)
    return;

    console.log('sellOrder', sellOrder)
    const tx = await ethers.provider.getTransactionReceipt('0x7cf6dffef7b3ecc095835264512bf3a16aab9589abb337e5500f9617509739d3');
    const eventData = exchange.contract.interface.decodeEventLog('OrdersMatched', tx.logs[1].data);

    // const tx2 = await ethers.provider.getTransactionReceipt('0x9e4e8ba883e49c296c16f7c06b7f68244c5b916085afee05d24be6d2f02716ca');
    // const args = exchange.contract.interface.decodeEventLog('OrdersMatched', tx2.logs[2].data, tx2.logs[2].topics);

    console.log('eventData', eventData);

    // const sellHash = args.sellHash.toLowerCase();
    // const buyHash = args.buyHash.toLowerCase();
    // const sell = args.sell;
    // const buy = args.buy;

    // console.log("OrdersMatched", {
    //   current: {
    //     maker: args.maker,
    //     taker: args.taker
    //   },
    //   sellHash,
    //   buyHash,
    //   newType: {
    //     sellSig: buy.signature,
    //     buySig: buy.v,
    //     maker: sell.trader,
    //     taker: buy.trader
    //   }
    // })

    // buyOrder.checkSignature();
  })
});
